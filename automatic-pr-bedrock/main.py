import boto3
import json
from pr_opener import *
import os
from flask import Flask, jsonify, request
from in_context_examples import *

app = Flask(__name__)

def get_vulnerabilities_from_dynamo(ecr_repo_name, table_name):
    dynamodb = boto3.resource('dynamodb')
    table = dynamodb.Table(table_name)
    
    try:
        response = table.get_item(Key={'ecr_repo_name': ecr_repo_name})
        if 'Item' in response:
            return response['Item']
        else:
            return None
    except Exception as e:
        print(f"Erro ao acessar DynamoDB: {str(e)}") 
        return None

def build_model_prompt(vulnerabilities_item, requirements, app_name):
    prompt = f"Application:{app_name}\nVulnerabilities:\n"
    
    for vulnerability in vulnerabilities_item.get('vulnerabilities', []):
        if vulnerability.get('library_name') not in prompt:
            prompt += f"- {vulnerability['library_name']} {vulnerability['current_version']} (fixed in {vulnerability['fixed_in_version']}): CVE {vulnerability['cve_id']}\n"
    
    prompt += f"\nCurrent `requirements.txt`:\n```\n{requirements}\n```\nSuggestions for improvement (Include all the libraries that are on the current requirements, dont matter if they have CVEs like medium ones, but bump only based on the Vulnerabilities fixed):"
    return prompt

def invoke_bedrock_model(prompt):
    brt = boto3.client(service_name='bedrock-runtime')
    body = json.dumps({
    "prompt": f"{prompt}",
    "max_gen_len": 2048,
    "temperature": 0.5,
    "top_p": 0.9,
    })
    modelId = 'meta.llama2-13b-chat-v1'
    accept = 'application/json'
    contentType = 'application/json'

    response = brt.invoke_model(body=body, modelId=modelId, accept=accept, contentType=contentType)
    response_body = json.loads(response.get('body').read())
    return response_body.get('generation')

def delete_local_repo(local_dir):
    if os.path.exists(local_dir):
        os.system(f"rm -rf {local_dir}")

@app.route('/analyze', methods=['POST'])
def analyze():
    data = request.get_json()
    ecr_repo_name = data.get('ecr_repo_name')
    aws_region=os.getenv("AWS_DEFAULT_REGION", "")
    
    print(f"Starting ML validation for CVE on repo: {ecr_repo_name}")
    
    table_name = 'aggregate-cve-results'
    user_id_code_commit=os.getenv("USER_ID", "")
    repo_url = f"ssh://{user_id_code_commit}@git-codecommit.{aws_region}.amazonaws.com/v1/repos/{ecr_repo_name}"
    local_dir = f"/tmp/{ecr_repo_name}"
    new_branch_name = 'cve_finder'
    key_path = "/root/.ssh/id_rsa" # Internal key in the container copied in Docker build
    requirements_updated = False
    model_analysis_completion = ""
    vulnerabilities_item = get_vulnerabilities_from_dynamo(ecr_repo_name, table_name)

    if vulnerabilities_item:
        # Need to clone first to get requirements dependencyx
        clone_codecommit_repo(repo_url, local_dir, key_path)
        # TBD: Creates validation method depending on the language of the app
        requirements_file = read_requirements_as_text(f"{local_dir}/requirements.txt")
        model_prompt = build_model_prompt(vulnerabilities_item, requirements_file, ecr_repo_name)
        final_model_prompt = python_incontext_learning + model_prompt
        
        while requirements_updated == False:
            model_analysis_completion = invoke_bedrock_model(final_model_prompt)
            print(model_analysis_completion)
            create_and_switch_to_branch(local_dir, new_branch_name)
            requirements_updated = update_requirements_from_text(model_analysis_completion, local_dir, new_branch_name)
        
        repository_name = ecr_repo_name
        source_branch = new_branch_name
        destination_branch = 'main'
        title = 'CVE Finder, please take a look and update with the following recommendations'
        description = model_analysis_completion
        create_codecommit_pull_request(repository_name, source_branch, destination_branch, title, description)
        
        # Delete repository after completition locally, create the steps below
        print("Deleting Local directory")
        delete_local_repo(local_dir)
        
        
        
        
        
    return jsonify({"message": "Analysis complete"}), 200

@app.route('/health', methods=['GET'])
def health():
    return '', 200


if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0')