# Automated vulnerability patching for secure application development

This repository contains the architecture and codebase for an automated remediation pipeline designed to address ECR Inspector findings using the power of Generative AI, specifically leveraging Amazon Bedrock's in-context learning capabilities.

## Overview

![Architecture Diagram](static/architecture-diagram.png)

The pipeline is designed to seamlessly integrate with your CI/CD workflow, providing a robust solution for vulnerability management. The diagram illustrates the complete solution, which comprises several interconnected components:

1. **CI Pipeline Integration**: Commences with a clone of the Application Repo, followed by static code analysis, image building, and local analysis using Trivy. The resultant image is then pushed to ECR.

2. **ECR and Inspector**: The ECR hosts the images, which are scanned by the Inspector. Findings are then evaluated for severity.

3. **Lambda Functions**:
    - **Aggregate Inspector Findings**: Gathers Inspector data and stores it into a DynamoDB table.
    - **Change Image Tag**: Tags the images in ECR as `prd-sha` or `risk-sha` based on Inspector findings.

4. **Amazon Bedrock with Generative AI**:
    - Receives aggregated data from the Lambda function.
    - Uses in-context learning to generate pull requests with remediation suggestions for vulnerabilities in the application repositories.

5. **ECS and Fargate Execution**: The application, with suggested fixes, is deployed using ECS and Fargate for a streamlined operation.

## Implemented Components

The current implementation focuses on three primary areas:

- **Lambda Function for Data Aggregation**: Central to the pipeline, it collects findings from Inspector and feeds them into DynamoDB.
- **Sample Applications with CVEs**: Provides real-world scenarios to test the pipeline's efficacy.
- **ECS Application with Generative AI**: Demonstrates the potential of Amazon Bedrock's AI to suggest code fixes by opening pull requests in the application repositories.

## Objective

The goal of this pipeline is to reduce the manual effort required in vulnerability remediation by automating the generation of fixes for security issues identified by ECR Inspector. It not only identifies the problems but also suggests the code changes necessary for a resolution.

## Deployment

Export Env Vars:
```bash
export AWS_REGION="us-west-1"
export ACCOUNT_ID="0500000000"
```

First thing that we need to do is create a `private` and `public` key that are going to be used inside the container for the `Automatic PR Application`.

```bash
ssh-keygen -t rsa -b 4096 -f suggested-automatic-pr-gen-ai/keys/cve_demo
```

Now we need to modify the Terraform variables based on our needs, open the file `terraform-new/variables.tf`, and replace the values accordngly to the example below:

```terraform
variable "aws_region" {
  default = "YOUR DESIRED REGION"
}
```

Plan Terraform script to provision `Infrastructure`:

```bash
cd terraform-new/ && terraform init && terraform plan
```

After a susccefull plan, it is time for applying:

```bash
# Make sure to be in the correct folder
terraform apply --auto-approve
```

Export `codecommit_user_ssh_key_id` to a environment variable:

```bash
export USER_ID="AKIXXXXXXXXX"
```

Push application code to `Code Commit` repositories, this is necessary because we use the `requirements.txt` within the `Generative AI` application, use the `Terraform Outputs`:

Adding SSH Key into `ssh-agent`

```bash
cd ..

eval "$(ssh-agent -s)"
ssh-add suggested-automatic-pr-gen-ai/keys/cve_demo
```

Clone Git repositories:

```bash
git clone ssh://APKXXXXXXXXX@git-codecommit.YOUR_REGION.amazonaws.com/v1/repos/my-amazing-application
git clone ssh://APKXXXXXXXXX@git-codecommit.YOUR_REGION.amazonaws.com/v1/repos/my-awesome-application
```

Copy files from local repo to `CodeCommit` repo

```bash
cp -r apps/my-amazing-application/* my-amazing-application/
cp -r apps/my-awesome-application/* my-awesome-application/
```

Commit files into the repository:

```bash
cd my-amazing-application/ && git add . && git commit -m "Initial Commit" && git push origin main

cd ../

cd my-awesome-application/ && git add . && git commit -m "Initial Commit" && git push origin main

cd ../
```

Now it is time to build the Docker image for the application that will generate the recommendations using Bedrock and Open the PR to the repository, this will be used to feed our Gen AI model, build the Docker image using ENV var for `AWS_DEFAULT_REGION` and `USER_ID`, see example below:

Login into AWS ECR Registry:

```bash
aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com
```

Build Image:

```bash
cd automatic-pr-bedrock/

docker build --build-arg AWS_DEFAULT_REGION=${AWS_REGION} --build-arg USER_ID=${USER_ID} -t ${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/automatic-pr-bedrock:latest .
```

Push image to the ECR repository.

```bash
docker push ${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/automatic-pr-bedrock:latest
```

## Testing the Architecture

### Building image for testing

1. We will build `my-amazing-application` image and push to Amazon ECR, we used the insights generated by inspector to create an on-shot inference using in-context learning from `my-awesome-application`.

```bash
cd ../apps/my-amazing-application

docker build -t ${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/my-amazing-application:1 .

docker push ${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/my-amazing-application:1
```
